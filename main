import csv
import pandas as pd
import numpy as np
import geopy as gp
import cmath
from geopy.distance import great_circle
import re
from scipy.fft import fft, ifft

pd.options.mode.chained_assignment = None


def point_to_GPS():
    """
    take coordinates from point in dataBangkok
    and write it to GPS in dataBangkok.csv
    """
    for i in range(len(dataBangkok["point"])):
        dataBangkok["GPS"][i] = dataBangkok["point"][i].replace('POINT', '').replace('(', '').replace(')', '')

def URL_to_GPS():
    """
    take gps from URL link and write it to places.csv in colomn "GPS
    """
    for i in range(len(places["Geo Location of the place"])):
        temp = re.search('(\d{1,}.\d{1,}!4d\d{1,}.\d{1,}$)', str(places["Geo Location of the place"][i]), re.DOTALL)
        if temp is not None:
            places["GPS"][i] = temp.group(0).split('!4d')[0] + ' ' + temp.group(0).split('!4d')[1]
        else:
            if places["Geo Location of the place"][i] is not None:
                s = re.search('(\d{1,}.\d{1,}!4d\d{1,}.\d{1,})', str(places["Geo Location of the place"][i]), re.DOTALL)
                if s is not None:
                    places["GPS"][i] = s.group(0).split('!4d')[0] + ' ' + s.group(0).split('!4d')[1]


def GPS_to_place():
    """
    For every GPS in Bangkok find place name in Data1["Place Name"]
    with comparing  Data1["GPS"] and Bangkok['GPS']
    for every GPS in Bangkok we will have np.array with distance from that point to all places from Data1["GPS"]
    and for point we will choose minimum from this np.array and write it to dataBangkok['place_name']
    """
    for i in range(len(bangkok['GPS'])):
        count = False
        min_index = 0
        min_distance = 0
        for j in range(len(data1['GPS'])):
            if data1['GPS'][j] != "":
                first = str(bangkok['GPS'][i]).split(" ")
                second = str(data1['GPS'][j]).split(" ")
                point1 = (float(first[1]), float(first[2]))
                point2 = 0
                if second != ['nan']:
                    point2 = (float(second[0]), float(second[1]))
                if point2 != 0:
                    distance = great_circle(point1, point2).meters
                    if count is False:
                        min_index = j
                        min_distance = distance
                        count = True
                    else:
                        if distance < min_distance:
                            min_distance = distance
                            min_index = j
        bangkok['place_name'][i] = data1["Place Name"][min_index]


def AAM(X, total):
    """
    :param X: np.array(x1,...,xn) - input signal
    :param total - maximum total frequency
    :return: S -> (abs(wk), (arg(wk), wk)
    """
    S = dict()
    k = 1
    W = fft(X)[0]
    #phase(number) = arctan(imaginary_part / real_part)
    phase1 = np.arctan(W.real / W.imag)
    S[W] = [abs(W), phase1, W]
    while k < total:
        k = k + 1
        W = fft(X)[k-1]
        phase = np.arctan(W.real / W.imag)
        if W in S.keys():
            S[W][0] = S[W][0] + abs(W)
            S[W][1] = np.average(S[W][1]) #how to change the phase shifts and find average
        else:
            S[W] = [abs(W), phase, W]
        #create cosin signal
        cos_sig = abs(W) * np.cos(2*np.pi*W + phase)
        ret = np.subtract(X, cos_sig)



if __name__ == "__main__":
    col_list1 = ["point", "crowded_ratio", "number_of_people", "timestamp", "location_group", "timezone"]
    col_list2 = ["Place Name", "Geo Location of the place"]
    dataBangkok = pd.read_csv("DataBangkok.csv", usecols=col_list1)
    places = pd.read_csv("Data.csv", usecols=col_list2)

    dataBangkok.insert(0, 'GPS', "")
    places.insert(0, 'GPS', "")
    point_to_GPS()
    URL_to_GPS()

    places.to_csv("Data1.csv", index=False)
    dataBangkok.to_csv("Bangkok.csv", index=False)

    colmn1 = ["GPS", "point", "crowded_ratio", "number_of_people", "timestamp", "location_group", "timezone"]
    colmn2 = ["GPS", "Place Name", "Geo Location of the place"]
    bangkok = pd.read_csv("Bangkok.csv", usecols=colmn1)
    data1 = pd.read_csv("Data1.csv", usecols=colmn2)

    # Create array with places names
    places_names = []
    for i in range(len(data1["GPS"])):
        if str(data1["GPS"][i]) != 'nan':
            places_names.append(places["Place Name"][i])

    bangkok.insert(1, "place_name", "")
    GPS_to_place()
    bangkok = bangkok.drop("point", axis=1)
    bangkok = bangkok.drop("GPS", axis=1)
    bangkok = bangkok.drop("timezone", axis=1)
    bangkok = bangkok.drop("location_group", axis=1)
    bangkok = bangkok.sort_values(["place_name", 'timestamp'], ascending=[True, True])
    bangkok.to_csv("sequence.csv", index=False)

    name_gps_csv = ["place_name", "crowded_ratio", "number_of_people", "timestamp"]
    name_gps = pd.read_csv("sequence.csv", usecols=name_gps_csv)


   #S = np.array([[4.5, 3.4, 5.4, 1.5],
                 #[3.5, 6.7, 11.8, 1.3]])
    #y = fft(S)[0]
    #print(y)
    #phase = np.arctan(y.real / y.imag)
    #print(phase)
    #cos_sig = abs(y) * np.cos(2 * np.pi * y + phase)
    #print(cos_sig)